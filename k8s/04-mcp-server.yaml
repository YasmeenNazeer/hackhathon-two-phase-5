apiVersion: apps/v1
kind: Deployment
metadata:
  name: mcp-server-deployment
  namespace: elevate-app
  labels:
    app: mcp-server
    app.kubernetes.io/name: mcp-server
    app.kubernetes.io/part-of: elevate-app
    app.kubernetes.io/version: "1.0.0"
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mcp-server
  template:
    metadata:
      labels:
        app: mcp-server
        app.kubernetes.io/name: mcp-server
        app.kubernetes.io/part-of: elevate-app
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 2000
      containers:
      - name: mcp-server
        image: python:3.11-slim
        imagePullPolicy: IfNotPresent
        workingDir: /app
        ports:
        - containerPort: 8001
          name: mcp-api
        env:
        - name: DATABASE_URL
          valueFrom:
            configMapRef:
              name: elevate-config
              key: DATABASE_URL
        - name: PYTHONPATH
          value: "/app"
        envFrom:
        - configMapRef:
            name: elevate-config
        command:
        - "python"
        - "-c"
        - |
          import subprocess
          import sys
          import os

          # Install dependencies
          os.system("apt-get update && apt-get install -y git gcc && pip install --no-cache-dir fastapi uvicorn httpx google-generativeai sqlmodel psycopg2-binary python-multipart pydantic-settings")

          # Create app directory and copy code
          os.makedirs('/app', exist_ok=True)
          os.chdir('/app')

          # Create the necessary directory structure
          os.makedirs('/app/mcp_server', exist_ok=True)

          # Create a simplified sdk_mock.py
          sdk_mock_content = '''
          from abc import ABC, abstractmethod
          from typing import Any, Dict, List, Optional, Union, Callable
          from pydantic import BaseModel, Field
          from sqlmodel import Session

          class FunctionDeclaration(BaseModel):
              name: str
              description: str
              parameters: Dict[str, Any]

          class TextContent(BaseModel):
              text: str
              type: str = "text"

          class CallToolResult(BaseModel):
              content: List[TextContent]

          class McpBaseTool(BaseModel):
              name: str
              description: Optional[str] = None
              inputSchema: Dict[str, Any] = Field(default_factory=dict)

          class MCPServer(ABC):
              @abstractmethod
              async def connect(self):
                  pass

              @property
              @abstractmethod
              def name(self) -> str:
                  pass

              @abstractmethod
              async def cleanup(self):
                  pass

              @abstractmethod
              async def list_tools(self) -> list[McpBaseTool]:
                  pass

              @abstractmethod
              async def call_tool(self, tool_name: str, arguments: Dict[str, Any] | None, session: Session) -> CallToolResult:
                  pass

          class TaskMCPServer(MCPServer):
              def __init__(self, name: str = "task_management_mcp_server", session_factory: Optional[Callable[[], Session]] = None):
                  self._name = name
                  self._tools: Dict[str, McpBaseTool] = {}
                  self._tool_implementations: Dict[str, Any] = {}
                  self.session_factory = session_factory

              @property
              def name(self) -> str:
                  return self._name

              async def connect(self):
                  print(f"{self.name} connected.")

              async def cleanup(self):
                  print(f"{self.name} cleaned up.")

              def register_tool(self, tool: McpBaseTool, implementation: Any):
                  self._tools[tool.name] = tool
                  self._tool_implementations[tool.name] = implementation

              async def call_tool(self, tool_name: str, arguments: Dict[str, Any] | None, session: Session) -> CallToolResult:
                  if tool_name not in self._tools:
                      return CallToolResult(content=[TextContent(text=f"Error: Tool '{tool_name}' not found.", type="text")])

                  tool_impl = self._tool_implementations[tool_name]
                  try:
                      result = await tool_impl(session=session, **(arguments or {}))
                      return CallToolResult(content=[TextContent(text=str(result), type="text")])
                  except Exception as e:
                      return CallToolResult(content=[TextContent(text=f"Error calling tool '{tool_name}': {e}", type="text")])

              async def list_tools(self) -> list[McpBaseTool]:
                  return list(self._tools.values())
          '''
          with open('/app/mcp_server/sdk_mock.py', 'w') as f:
              f.write(sdk_mock_content)

          # Create a simplified mcp_tools.py
          mcp_tools_content = '''
          from typing import Optional, Dict, Any, List
          from pydantic import BaseModel, Field
          from datetime import datetime, timezone
          from uuid import UUID

          from sqlmodel import Session, select

          from mcp_server.sdk_mock import McpBaseTool

          class AddTaskInput(BaseModel):
              user_id: str = Field(description="The ID of the user for whom to add the task.")
              title: str = Field(description="The title of the task.")
              description: Optional[str] = Field(None, description="The description of the task.")
              category: Optional[str] = Field("Personal", description="The category of the task (e.g., Personal, Work, Shopping).")
              due_date: Optional[datetime] = Field(None, description="The due date for the task.")

          class ListTasksInput(BaseModel):
              user_id: str = Field(description="The ID of the user for whom to list tasks.")

          class CompleteTaskInput(BaseModel):
              user_id: str = Field(description="The ID of the user who owns the task.")
              task_id: UUID = Field(description="The ID of the task to complete.")

          class DeleteTaskInput(BaseModel):
              user_id: str = Field(description="The ID of the user who owns the task.")
              task_id: UUID = Field(description="The ID of the task to delete.")

          class UpdateTaskInput(BaseModel):
              user_id: str = Field(description="The ID of the user who owns the task.")
              task_id: UUID = Field(description="The ID of the task to update.")
              title: Optional[str] = Field(None, description="The new title for the task.")
              description: Optional[str] = Field(None, description="The new description for the task.")
              is_completed: Optional[bool] = Field(None, description="The new completion status for the task.")
              category: Optional[str] = Field(None, description="The new category for the task.")
              due_date: Optional[datetime] = Field(None, description="The new due date for the task.")

          async def add_task_impl(session: Session, user_id: str, title: str, description: Optional[str] = None, category: Optional[str] = "Personal", due_date: Optional[datetime] = None) -> str:
              return f"Task '{title}' for user {user_id} added successfully (simulated)."

          async def list_tasks_impl(session: Session, user_id: str) -> str:
              return f"No tasks found for user {user_id} (simulated)."

          async def complete_task_impl(session: Session, user_id: str, task_id: UUID) -> str:
              return f"Task with ID {task_id} for user {user_id} marked as complete (simulated)."

          async def delete_task_impl(session: Session, user_id: str, task_id: UUID) -> str:
              return f"Task with ID {task_id} for user {user_id} deleted (simulated)."

          async def update_task_impl(session: Session, user_id: str, task_id: UUID, title: Optional[str] = None, description: Optional[str] = None, is_completed: Optional[bool] = None, category: Optional[str] = None, due_date: Optional[datetime] = None) -> str:
              return f"Task with ID {task_id} for user {user_id} updated successfully (simulated)."

          ADD_TASK_TOOL = McpBaseTool(
              name="add_task",
              description="Adds a new task for a user.",
              inputSchema=AddTaskInput.model_json_schema()
          )

          LIST_TASKS_TOOL = McpBaseTool(
              name="list_tasks",
              description="Lists all tasks for a user.",
              inputSchema=ListTasksInput.model_json_schema()
          )

          COMPLETE_TASK_TOOL = McpBaseTool(
              name="complete_task",
              description="Marks a user's task as complete.",
              inputSchema=CompleteTaskInput.model_json_schema()
          )

          DELETE_TASK_TOOL = McpBaseTool(
              name="delete_task",
              description="Deletes a user's task.",
              inputSchema=DeleteTaskInput.model_json_schema()
          )

          UPDATE_TASK_TOOL = McpBaseTool(
              name="update_task",
              description="Updates the title, description, category, due date, or completion status of an existing user's task.",
              inputSchema=UpdateTaskInput.model_json_schema()
          )

          TOOL_IMPLEMENTATIONS = {
              ADD_TASK_TOOL.name: add_task_impl,
              LIST_TASKS_TOOL.name: list_tasks_impl,
              COMPLETE_TASK_TOOL.name: complete_task_impl,
              DELETE_TASK_TOOL.name: delete_task_impl,
              UPDATE_TASK_TOOL.name: update_task_impl,
          }

          ALL_TOOLS = [
              ADD_TASK_TOOL,
              LIST_TASKS_TOOL,
              COMPLETE_TASK_TOOL,
              DELETE_TASK_TOOL,
              UPDATE_TASK_TOOL,
          ]
          '''
          with open('/app/mcp_server/mcp_tools.py', 'w') as f:
              f.write(mcp_tools_content)

          # Create main.py for mcp_server
          main_content = '''
          from contextlib import asynccontextmanager
          from fastapi import FastAPI, HTTPException, Depends
          from pydantic import BaseModel
          from typing import Dict, Any, List
          import httpx
          from sqlmodel import Session

          from mcp_server.sdk_mock import TaskMCPServer, CallToolResult, McpBaseTool
          from mcp_server.mcp_tools import ALL_TOOLS, TOOL_IMPLEMENTATIONS

          # In a real scenario, we would have a proper database connection
          # For this demo, we'll simulate the database connection
          class MockSession:
              pass

          def get_session():
              return MockSession()

          @asynccontextmanager
          async def lifespan(app: FastAPI):
              # Simulate connecting
              print("MCP Server connected")
              yield
              # Simulate cleanup
              print("MCP Server cleaned up")

          app = FastAPI(lifespan=lifespan)
          task_mcp_server = TaskMCPServer()

          for tool_def in ALL_TOOLS:
              task_mcp_server.register_tool(tool_def, TOOL_IMPLEMENTATIONS[tool_def.name])

          class MCPRequest(BaseModel):
              tool_name: str
              arguments: Dict[str, Any]

          class MCPResponse(BaseModel):
              results: CallToolResult

          @app.get("/health")
          async def health_check():
              return {"status": "healthy", "component": "mcp-server"}

          @app.post("/mcp_call", response_model=MCPResponse)
          async def mcp_call_endpoint(request_data: MCPRequest):
              try:
                  # Create a mock session for the demo
                  mock_session = get_session()
                  results = await task_mcp_server.call_tool(request_data.tool_name, request_data.arguments, mock_session)
                  return MCPResponse(results=results)
              except Exception as e:
                  raise HTTPException(status_code=500, detail=str(e))

          @app.get("/mcp_tools", response_model=List[McpBaseTool])
          async def list_mcp_tools():
              return await task_mcp_server.list_tools()

          if __name__ == "__main__":
              import uvicorn
              uvicorn.run(app, host="0.0.0.0", port=8001)
          '''
          with open('/app/mcp_server/main.py', 'w') as f:
              f.write(main_content)

          # Run the app
          os.system("cd /app && python mcp_server/main.py")
        livenessProbe:
          httpGet:
            path: /health
            port: 8001
          initialDelaySeconds: 15
          periodSeconds: 10
          timeoutSeconds: 5
        readinessProbe:
          httpGet:
            path: /health
            port: 8001
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        volumeMounts:
        - name: temp-volume
          mountPath: /tmp
      volumes:
      - name: temp-volume
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: mcp-server-service
  namespace: elevate-app
  labels:
    app.kubernetes.io/name: mcp-server
    app.kubernetes.io/part-of: elevate-app
spec:
  selector:
    app: mcp-server
  ports:
    - protocol: TCP
      port: 8001
      targetPort: 8001
      name: mcp-api
  type: ClusterIP